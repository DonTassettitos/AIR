/**
 * Copyright (c) 2020 University of Luxembourg. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors may be
 * used to endorse or promote products derived from this software without specific prior
 * written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF LUXEMBOURG AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE UNIVERSITY OF LUXEMBOURG OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/

/*  
   NEXMark Generator -- Niagara Extension to XMark Data Generator

   Acknowledgements:
   The NEXMark Generator was developed using the xmlgen generator 
   from the XMark Benchmark project as a basis. The NEXMark
   generator generates streams of auction elements (bids, items
   for auctions, persons) as opposed to the auction files
   generated by xmlgen.  xmlgen was developed by Florian Waas.
   See http://www.xml-benchmark.org for information.

   Copyright (c) Dept. of  Computer Science & Engineering,
   OGI School of Science & Engineering, OHSU. All Rights Reserved.

   Permission to use, copy, modify, and distribute this software and
   its documentation is hereby granted, provided that both the
   copyright notice and this permission notice appear in all copies
   of the software, derivative works or modified versions, and any
   portions thereof, and that both notices appear in supporting
   documentation.

   THE AUTHORS AND THE DEPT. OF COMPUTER SCIENCE & ENGINEERING 
   AT OHSU ALLOW USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION, 
   AND THEY DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES 
   WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.

   This software was developed with support from NSF ITR award
   IIS0086002 and from DARPA through NAVY/SPAWAR 
   Contract No. N66001-99-1-8098.

*/

/*
 * EventGenerator.cpp
 *
 *  Created on: April 2, 2020
 *      Author: damien.tassetti
 */

#include <mpi.h>
#include <unistd.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <iterator>
#include <list>
#include <string>
#include <vector>
#include <cctype>
#include <algorithm>
#include <iomanip> // std::setprecision

#include "../communication/Window.hpp"
#include "EventGenerator.hpp"
#include "Random.hpp"
#include "../serialization/Serialization.hpp"

using namespace std;
using nexmark_gen::EventGenerator;
using nexmark_gen::Event;

EventGenerator::EventGenerator(int tag, int rank, int worldSize,
									 unsigned long tp) : Vertex(tag, rank, worldSize),
									 throughput(tp),
									 events_per_msg(tp / PER_SEC_MSG_COUNT / worldSize),
									 auctions(AuctionsManager(min_auction_duration, worldSize, rank)),
									 persons(PersonsManager(worldSize, rank)),
									 time_increment_per_event(1.0 / (tp / worldSize)),
									 iteration_count(0),
									 starting_second((int)MPI_Wtime()),
									 msg_count(0)
{
	// cout << "person " << sizeof(Person) << endl;
	// cout << "auction " << sizeof(Auction) << endl;
	// cout << "bid " << sizeof(Bid) << endl;
	// cout << "event " << sizeof(Event) << endl;

	S_CHECK(
		bids_datafile.open("nexmarkgen_bids_" + to_string(rank) + ".tsv");
		auctions_datafile.open("nexmarkgen_auctions_" + to_string(rank) + ".tsv");
		persons_datafile.open("nexmarkgen_persons_" + to_string(rank) + ".tsv");
	)
}

EventGenerator::~EventGenerator() {
	bids_datafile.close();
	auctions_datafile.close();
	persons_datafile.close();
}

void EventGenerator::streamProcess(int channel)
{
	Message *message;
	Message **outMessagesPerSec = new Message *[PER_SEC_MSG_COUNT];

	while (ALIVE)
	{
		// generate messages
		msg_count = 0;
		while (msg_count < PER_SEC_MSG_COUNT)
		{
			// outMessagesPerSec[msg_count] = new Message(events_per_msg * sizeof(Event) + sizeof(int));
			outMessagesPerSec[msg_count] = initMessage(events_per_msg * sizeof(Event) + sizeof(int));

			// add Message body
			getNextMessage(outMessagesPerSec[msg_count], events_per_msg);

			// add message id
			const unsigned int message_id = msg_count + iteration_count * PER_SEC_MSG_COUNT;
			const unsigned int global_id = message_id * worldSize + rank;
			addMessageId(global_id, outMessagesPerSec[msg_count]);

			msg_count++;
		}

		// wait for the end of 1 second, time is in microseconds
		const long int expected_time_lower = (long int)(starting_second + iteration_count) * 1000000;
		const long int expected_time_upper = expected_time_lower + 1000000;
		const long int current_time = getCurrentTimeInMicroseconds();

		if (current_time < expected_time_lower){
			cerr << "! Careful : event generator " << rank << " is too fast by " << expected_time_lower - current_time << " usec\n";
		} else if (current_time < expected_time_upper){
			while ( getCurrentTimeInMicroseconds() < expected_time_upper ){
				usleep(100);
			}
		} else {
			cerr << "! Careful : event generator " << rank << " is too slow by " << current_time - expected_time_upper << " usec\n";
		}

		// send messages
		msg_count = 0;
		while (msg_count < PER_SEC_MSG_COUNT)
		{
			// next node is aggregator on rank 0, df 0
			for (size_t operatorIndex = 0; operatorIndex < next.size(); operatorIndex++) {
				const int channel = operatorIndex * worldSize + rank; // same rank

				// copy message content, else double free or segfault if nof_operators > 1
				Message* outMessage = Serialization::copy(outMessagesPerSec[msg_count]);

				// Normal mode: synchronize on outgoing message channel & send message
				send(outMessage, channel);
			}

			msg_count++;
		}

		iteration_count++;
	}
}

void EventGenerator::addMessageId(const int message_id, Message* message){
	Serialization::wrap<unsigned int>(message_id, message);
}

Message* EventGenerator::initMessage(size_t capacity) {
	return new Message(capacity); 
}

void EventGenerator::send(Message*const message, int channel) {

	pthread_mutex_lock(&senderMutexes[channel]);
	outMessages[channel].push_back(message);
	pthread_cond_signal(&senderCondVars[channel]);
	pthread_mutex_unlock(&senderMutexes[channel]);
}

void EventGenerator::getNextMessage(Message *message, int events_per_msg)
{
	nof_events = 0;
	while (nof_events < events_per_msg) {
		// we are using the wall-clock for timestamping,
		// which is a bit different from the Java version 
		// of the generator

		// on startup, create 10 persons to have someone to bid on auctions
		if (min_persons / worldSize > generated_persons) {
			Serialization::wrap<Event>(generatePerson(), message);
			generated_persons++;
		}

		// on startup, create 10 open auctions to have something to bid on
		else if (min_auctions / worldSize > generated_auctions) {
			Serialization::wrap<Event>(generateAuction(), message);
			generated_auctions++;
		}

		// after that, follow the given distribution
		else {
			int rnd = Random::getRandomInt(1, auction_chances + bid_chances + person_chances);
			int acc = 0;
			if (rnd <= (acc += bid_chances)) {
				Serialization::wrap<Event>(generateBid(), message);
			} else if (rnd <= (acc += auction_chances)) {
				Serialization::wrap<Event>(generateAuction(), message);
			} else if (rnd <= (acc += person_chances)) {
				Serialization::wrap<Event>(generatePerson(), message);
			}
		}
		nof_events++;
	}
}

Event EventGenerator::generateBid() {

	Bid bid = Bid();

	bid.auction_id = auctions.getExistingOpenAuctionId(); // depends on the rank & world size

	bid.item_id = bid.auction_id;

	auctions.increasePrice(bid.auction_id);
	bid.amount = auctions.getPrice(bid.auction_id);
	
	bid.bidder_id = persons.getExistingId(); // depends on rank & world size

	bid.event_time = starting_second + iteration_count + (double)msg_count / (double)PER_SEC_MSG_COUNT + time_increment_per_event * nof_events;

	Event res = {
		BidType, // event type
		{.bid=bid} // event of type Bid
	};

	// sanity check
	S_CHECK(
		bids_datafile << setprecision(16)
		<< res.bid.bidder_id << '\t'
		<< res.bid.amount << '\t'
		<< res.bid.auction_id << '\t'
		<< res.bid.event_time << endl;
	);
	return res;
}

Event EventGenerator::generateAuction() {

	Auction auction = Auction();
	auction.id = auctions.getNewId(); // ensures each rank uses different ids
	auction.category_id = Random::getRandomInt(0, 303); // strange, there should be 1000 categories
	auction.seller_id = persons.getExistingId();
	auction.event_start = starting_second + iteration_count + (double)msg_count / (double)PER_SEC_MSG_COUNT + time_increment_per_event * nof_events;
	auction.event_end = auction.event_start + min_auction_duration + Random::getRandomInt(0, max_auction_duration);

	if (Random::getRandomInt(0,1) == 0) {
		double reserve_factor = (Random::getRandomInt(0, 10) / 10.0) + 2.2; // desired selling price
		auction.reserve_price = (int)(auctions.getPrice(auction.id) * reserve_factor);
		auction.reserve_price_is_null = false;
	} else {
		auction.reserve_price_is_null = true;
		auction.reserve_price = 0;
	}
	
	if (Random::getRandomInt(0,1) == 0) {
		auction.privacy = (bool)Random::getRandomInt(0, 1);
		auction.privacy_is_null = false;
	} else {
		auction.privacy_is_null = true;
		auction.privacy = false;
	}

	auction.quantity = Random::getRandomInt(1, 10);
	auction.importance = (AuctionImportance)Random::getRandomInt(0,1); // featured or regular auction

	if (auction.quantity > 1) {
		auction.bidding_rules = (BiddingRules)Random::getRandomInt(0, 1); // normal or dutch
	} else {
		auction.bidding_rules = NormalBiddingRules;
	}

	auctions.update(auction);
	Event res = {
		AuctionType,
		{.auction=auction}
	};

	// sanity check
	S_CHECK(
		auctions_datafile << setprecision(16)
		<< res.auction.id << '\t'
		<< res.auction.seller_id << '\t';

		if (res.auction.reserve_price_is_null){
			auctions_datafile << '0' << '\t';
		} else {
			auctions_datafile << res.auction.reserve_price << '\t';
		}

		auctions_datafile << res.auction.event_start << endl;
	);

	return res;
}

Event EventGenerator::generatePerson() {

	Person person;
	string first_name = persons.getFirstName();
	string last_name = persons.getLastName();
	string email_extension = persons.getEmailExtension();

	string name = first_name + " " + last_name;
	string email = first_name + "." + last_name + "@" + email_extension;

	bool has_address = false;
	string state = "";
	string city = "";
	string street = "";
	int zip_code = 0;

	bool has_phone = false;
	string phone = "";

	bool has_homepage = false;
	string homepage = "";

	bool has_credit_card = false;
	string credit_card = "";

	bool has_profile = false;
	bool has_education = false;
	string education = "";
	bool has_gender = false;
	string gender = "";
	bool has_age = false;
    int age = 0;
	bool has_business = false;
    double income = 0.0;
	int nof_interests = Random::getRandomInt(0,4); // between 0 and 4 categories of interest
    int interest1 = Random::getRandomInt(0, nof_categories); // 1000 categories
    int interest2 = Random::getRandomInt(0, nof_categories);
    int interest3 = Random::getRandomInt(0, nof_categories);
    int interest4 = Random::getRandomInt(0, nof_categories);

	// build address
	if (Random::getRandomInt(0, 1) == 0) {
		has_address = true;
		state = persons.getRandomState();
		city = persons.getRandomCity();
		street = persons.getRandomStreet();
		zip_code = persons.getRandomZipCode();
	}

	// build phone number
	if (Random::getRandomInt(0, 1) == 0) {
		has_phone = true;
		phone = persons.getRandomPhoneNumber();
	}

	// build homepage
	if (Random::getRandomInt(0,1) == 0){
		has_homepage = true;
		homepage = "http://www." + email_extension + "/~" + last_name;
	}

	// build credit card information
	if (Random::getRandomInt(0,1) == 0){
		has_credit_card = true;
		credit_card = persons.getRandomCreditcard();
	}

	// build profile
	if (Random::getRandomInt(0,1) == 0){
		has_profile = true;
		has_business = (bool)Random::getRandomInt(0, 1);
		income = persons.getRandomIncome();
		if (Random::getRandomInt(0,1) == 0){
			has_education = true;
			education = persons.getRandomEducation();
		}
		if (Random::getRandomInt(0,1) == 0){
			has_gender = true;
			gender = persons.getRandomGender();
		}
		if (Random::getRandomInt(0,1) == 0){
			has_age = true;
			age = persons.getRandomAge();
		}
	}

	// add everything to the event
	person.id = persons.getNewId(); // ensures each rank uses different ids
	sprintf(person.name, "%34s", name.c_str()); // string is always X chars + \0

	person.has_address = has_address;
	sprintf(person.state, "%30s", state.c_str());
	sprintf(person.city, "%15s", city.c_str());
	person.zip_code = zip_code;
	sprintf(person.street, "%22s", street.c_str());

	sprintf(person.email, "%58s", email.c_str());

	person.has_phone = has_phone;
	sprintf(person.phone, "%15s", phone.c_str());

	person.has_homepage = has_homepage;
	sprintf(person.homepage, "%53s", homepage.c_str());

	person.has_credit_card = has_credit_card;
	sprintf(person.credit_card, "%19s", credit_card.c_str());

	person.has_profile = has_profile;
	person.has_education = has_education;
	sprintf(person.education, "%15s", education.c_str());
	person.has_gender = has_gender;
	sprintf(person.gender, "%6s", gender.c_str());
	person.has_age = has_age;
	person.age = age;
	person.has_business = has_business;
	person.income = income;
	person.nof_interests = nof_interests;
	person.interest1 = interest1;
	person.interest2 = interest2;
	person.interest3 = interest3;
	person.interest4 = interest4;
	person.timestamp = starting_second + iteration_count + (double)msg_count / (double)PER_SEC_MSG_COUNT + time_increment_per_event * nof_events;

	Event res = {
		PersonType,
		{.person=person}
	};

	// output everything needed for sanity check
	S_CHECK(
		persons_datafile << setprecision(16)
		<< res.person.id << '\t';

		// remove duplicate whitespaces from person name
		string str(res.person.name);
		string::iterator new_end = std::unique(str.begin(), str.end(), [](char lhs, char rhs){ return (lhs == rhs) && (lhs == ' ');});
		str.erase(new_end, str.end()); 

		persons_datafile
		<< str << '\t'
		<< res.person.timestamp << endl;
	);

	return res;
}
